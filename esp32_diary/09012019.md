# #5. Validation Philosophy

**9^th^ January, 2019**

------

I figured out that this is something that's not talked about anywhere but is an important aspect to discuss while designing the apps for ESP32. This came into context when I began using C++ for leveraging the *class* definitions which are not available on C. 

## Basic Idea

The basic idea is to develop a good distinction between the parts of your project that bind to the hardware and those which govern the logic.  It's always recommended to  keep both these aspects separate in your code.

> Note that the functions used here are not based on actual ESP32 libraries. These are just illustrative functions.

Let's take a simple example - a proportional motor controller (Ignore any scientific mistakes):

```c++
#include <iostream>
#include "hardware library"

class Motor(){
    private:
    float pwm_duty;
    int delta_pos;
    float prop_coeff;
    
    public:
    void Motor(){
        pwm_duty = 0.0;
        delta_pos = 0;
        prop_coeff = 10.0;
    }
    void driveMotor(){
        // A hardware function from the motor driver library
        hw_motor_set_pwm(pwm_duty);
    }
    void getDiff(){
        // Find (Target - Current) Angle
        // Again a hardware function
        delta_pos = hw_get_encoder_diff();
    }
    void computeMotor(){
        // Main logic for motor driving
        pwm_duty = prop_coeff*delta_pos;
    }
    
}

extern "C" void app_main(){
    std::cout << "Initialized Example" << std::endl;
    Motor m1;
    while(true){
        m1.getDiff();
        m1.computeMotor();
        m1.driveMotor();
        hw_delay(200);		//milleseconds
    }
}
```

## The problem

In order to test this on the hardware, I need to compile this app, which takes about 40-60 seconds and then flash it on to the hardware. This as you can see is time-consuming process which could have been bypassed, if it was to just check the program logic. 

Refining the above, we have the following levels of debugging:

* Program Logic Validation (doesn't require hardware)

  In the above example, the function `computeMotor()` is a logic.

* Hardware Validation (requires hardware)

  In the example,  `driveMotor()` and `getDiff()` are functions dependent on the hardware

## ESP Logging in awesome, but..

There's a library for ESP logging which basically collects and logs the return arguments of hardware relevant functions. This is one of the best ways for the second level of debugging. Typically all hardware functions on ESP32 are designed to return success status. 

If you simply call the function, the return value is not stored anywhere and hence vanishes.

```c++
hw_motor_set_pwm(pwm_duty);
```

Instead you can call the following

```c++
esp_log(hw_motor_set_pwm(pwm_duty));
```

This essentially prints a faded statement indicating the success of execution. 

This tool extremely powerful for debugging hardware quirks but is totally irrelevant in analyzing the program logic. 

## Primitive Idea

When I first faced this situation, I came with the idea of locally executing the program to resolve syntax or logic errors. I cloned the entire program into a different directory and used `g++` to execute the program. Before execution I cleaned up the code to be free of any hardware functions. Wherever functionally required, I replaced them with print functions or fake functions containing arbitrary return values.

Here's how I modified the above code

```c++
#include <iostream>

class Motor(){
    private:
    float pwm_duty;
    int delta_pos;
    float prop_coeff;
    
    public:
    void Motor(){
        pwm_duty = 0.0;
        delta_pos = 0;
        prop_coeff = 10.0;
    }
    void driveMotor(){
        // A hardware function from the motor driver library
        std::cout << "Motor driven with" << pwm_duty << "pwm duty" << std::endl;
    }
    void getDiff(){
        // Find (Target - Current) Angle
        // Again a hardware function
        delta_pos = hw_get_encoder_diff();
    }
    void computeMotor(){
        // Main logic for motor driving
        pwm_duty = prop_coeff*delta_pos;
    }
    
}

int main(){
    std::cout << "Initialized Example" << std::endl;
    Motor m1;
    while(true){
        m1.getDiff();
        m1.computeMotor();
        m1.driveMotor();
        hw_delay(200);		//milleseconds
    }
    return 0;
}
```

This code, instead of being compiled by the ESP32 xtensa toolchain, can be compiled and executed using the standard g++ installation.

`g++  <file_name>.cpp`

`./a.out`

## Playing with Pre-compilers

As you can see in the above idea, there's a need to branch out your project into two divisions - the actual ESP32 code and a separate code for logic testing. 

We can improve on this idea by trying to maintain only one codebase that can possess dual functionality. This can be done using pre-compilers in C++. Using the `#if` statements to isolate the logic part and the

## Simulation Header

Incorporating this idea